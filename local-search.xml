<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Achieving Differential Privacy and Fairness in Logistic Regression</title>
    <link href="/2022/04/07/Achieving%20Diferential%20Privacy%20and%20Fairness%20in%20Logistic%20Regression/"/>
    <url>/2022/04/07/Achieving%20Diferential%20Privacy%20and%20Fairness%20in%20Logistic%20Regression/</url>
    
    <content type="html"><![CDATA[<h1 id="achieving-diferential-privacy-and-fairness-in-logistic-regression">Achieving Diferential Privacy and Fairness in Logistic Regression</h1><h2 id="摘要">1. 摘要</h2><p><strong>背景：</strong> 机器学习算法的正常运行依赖于大量的敏感信息，因此引发了社会各界对隐私和机器学习公平性等问题的担忧。</p><p><strong>研究现状</strong> 目前，机器学习领域的许多研究要么只关注隐私，要么只关注机器学习公平性，如何同时实现隐私和机器学习公平还有待挖掘。</p><p><strong>创新点</strong> 论文提出了两种在 <span class="math inline">\(Logistic\)</span> 回归上同时实现隐私保护和机器学习公平的方法。</p><p>这篇论文和需要函数机制作为先验知识，可以先阅读另一篇博客 <a href="https://mrxulovemingming.github.io/2022/04/05/Functional-Mechanism-Regression-Analysis-under-Differential-Privacy/">Functional Mechanism</a>。</p><h2 id="介绍">2. 介绍</h2><p>论文提出了两种方法在 <span class="math inline">\(Logistic\)</span> 回归上同时实现差分隐私和机器学习公平。</p><ul><li>将公平性约束转化为目标函数的惩罚项，然后在整个目标函数上应用 <a href="https://arxiv.org/abs/1208.0219">函数机制</a> 来实现差分隐私</li><li>前一种方法的改进，加入了非零均值的 <span class="math inline">\(Laplace\)</span> 噪声作为等价的公平性约束。减少噪声的注入以保证精度。</li></ul><h2 id="准备工作">3.准备工作</h2><h3 id="符号定义">3.1 符号定义</h3><table><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(D=\{X,S,Y\}\)</span></td><td style="text-align: center;">包含 <span class="math inline">\(n\)</span> 条数记录的数据集</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(X=(X_1,X_2....X_d)\)</span></td><td style="text-align: center;">有 <span class="math inline">\(d\)</span> 个特征的非保护属性</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(S\)</span></td><td style="text-align: center;">保护属性</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(Y\)</span></td><td style="text-align: center;">标签</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\widehat{y}\)</span></td><td style="text-align: center;">预测值</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\omega\)</span></td><td style="text-align: center;">权重</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(t_i=\{x_i,s_i,y_i\}\)</span></td><td style="text-align: center;">第 <span class="math inline">\(i\)</span> 条记录</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(f({t_i};\omega)\)</span></td><td style="text-align: center;">单个记录的损失函数</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(f_D(\omega)= \sum_{i=1}^nf(t_i,\omega)\)</span></td><td style="text-align: center;">目标函数</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\bar\omega = arg \min_{\omega}\sum_{i=1}^nf(t_i;\omega)\)</span></td><td style="text-align: center;">损失函数最小时，对应的权重</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(g_D(\omega)\)</span></td><td style="text-align: center;">公平性约束项</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\tau\)</span></td><td style="text-align: center;">公平性约束的阈值</td></tr></tbody></table><h3 id="部分说明">3.2 部分说明</h3><ul><li><strong>保护属性：</strong> 性别，年龄等与公平性高度相关的属性。</li><li><strong>非保护属性：</strong> 保护属性之外的其他属性。</li><li><strong>特殊说明：</strong> 论文使保护属性，非保护属性，标签均为二值属性 <span class="math inline">\(\{0,1\}\)</span></li></ul><h3 id="函数机制">3.3 函数机制</h3><p>函数机制的详细描述可查看我的另一篇博客 <a href="https://mrxulovemingming.github.io/2022/04/05/Functional-Mechanism-Regression-Analysis-under-Differential-Privacy/">Functional Mechanism: Regression Analysis under Differential Privacy - 故、梦</a></p><h3 id="分类公平">3.4 分类公平</h3><p>公平是一个十分抽象的概念，看似公平的情形换个角度看就不再公平，即不存在绝对的公平。</p><p>分类公平中有很多种公平性规则，论文使用 <span class="math inline">\(Demographic {\,} Parity\)</span> 作为公平性规则。</p><p><span class="math inline">\(Demographic {\,} Parity\)</span> 要求预测结果与保护属性无关，即 <span class="math display">\[Pr(\widehat{Y}=1|S=1)=Pr(\widehat{Y}=1|S=0) \tag{1} \quad\]</span> 不公平程度 <span class="math inline">\(RD\)</span> 可以由以下式子表示： <span class="math display">\[RD = |Pr(\widehat{Y}=1|S=1)-Pr(\widehat{Y}=1|S=0)| \tag{2} \quad\]</span></p><p>公平性约束项 <span class="math inline">\(g_D(\omega) = \sum_{i=1}^n(s_i-\bar{s})x_i^T\omega\)</span> <strong>「 <span class="math inline">\(s_i\)</span> 为第 <span class="math inline">\(i\)</span> 条记录的保护属性值，<span class="math inline">\(\bar{s}\)</span> 为保护属性的均值」</strong></p><h2 id="算法理论">4. 算法理论</h2><h3 id="pflr">4.1 PFLR</h3><p>加入公平性约束项后，新的目标函数 <span class="math inline">\(\tilde{f}_D(\omega) = f_D(\omega) + \alpha|g_D(\omega)-\tau|\)</span></p><blockquote><p><strong><span class="math inline">\(\alpha\)</span> 是一个用于平衡公平性和精度的超参数，<span class="math inline">\(\tau\)</span> 是公平性约束的阈值</strong></p></blockquote><p>根据函数机制，将新的目标函数用泰勒展开到 <span class="math inline">\(2\)</span> 阶 <span class="math display">\[\tilde{f}_D(\omega) = \left(\sum_{i=1}^n\sum_{j=0}^2\frac{f_1^{(j)}(0)}{j!}(x_i^T\omega)^j \right)-\left( \sum_{i=1}^ny_ix_i^T \right)\omega + \alpha \left | \sum_{i=1}^n(s_i-\bar{s})x_i^T\omega - \tau {\,} \right | \tag{3} \quad\]</span> <strong><span style="background-color : cyan">与函数机制在 <span class="math inline">\(Logistic\)</span> 回归上的展开不同，PFLR 多了一个一次项。</span></strong></p><p>为了方便说明，令 <span class="math inline">\(\alpha=1\)</span> ，<span class="math inline">\(\tau = 0\)</span> 。那么 <span class="math inline">\(\tilde{f}_D(\omega)\)</span> 的全局敏感度 <span class="math inline">\(\Delta_{\tilde{f}}\)</span> 为： <span class="math display">\[\Delta_{\tilde{f}} = 2 \max_t \left(\left| \left(\frac{f_1^{(1)}(0)}{1!} - y + |s-\bar{s}| \right)\sum_{l=1}^dx_{(l)} \right|   +\left|\frac{f_1^{(2)}(0)}{2!}\sum_{l,m}^dx_{(l)}x_{(m)} \right |\right)\\ \le 2{\,}(\frac{3d}{2}+\frac{d^2}{8}) = \frac{d^2}{4}+3d\]</span></p><hr /><center>PFLR</center><hr /><ol type="1"><li>计算 <span class="math inline">\(\mu\)</span> 的全局敏感度 <span class="math inline">\(\Delta_g\)</span></li><li>将新的目标函数用泰勒在 0 处展开到 2 阶</li><li>计算展开式的全局敏感度</li><li>根据得到的全局敏感度，往目标函数中加入拉普拉斯噪声</li><li>根据扰动的目标函数训练模型，得到权重</li></ol><hr /><h3 id="pflr-1">4.2 PFLR<span class="math inline">\(^*\)</span></h3><p>相比于普通的函数机制， PFLR <strong>要求非保护组和保护组到决策边界有相同的距离</strong>。</p><p>在 FPLR 中我们发现公平性约束可以叠加到函数机制目标函数的一次项上。</p><p>根据这个思路，可以直接将公平性约束加入到一次项的噪声中，这样就能减少噪声的注入。</p><p>具体实现是将拉普拉斯噪声的均值 <span class="math inline">\(\mu\)</span> 由 <span class="math inline">\(0\)</span> 改为 <span class="math inline">\(\sum_{i=1}^n(s_i-\bar{s})x_i\)</span> ，</p><p>FPLR 的全局敏感度此时等于函数机制的全局敏感度：<span class="math inline">\(\Delta_f=\frac{d^2}{4}+d\)</span></p><p><strong><span style="background-color: cyan">然而，求解出的 <span class="math inline">\(\mu\)</span> 已经造成了隐私的泄露。所以需要在 <span class="math inline">\(\mu\)</span> 中加入差分隐私。 </span></strong></p><p><span class="math inline">\(\mu\)</span> 的全局敏感度可以表示为： <span class="math display">\[\Delta g=2 {\,}\max_{t}\left|\sum_{l=1}^d(s_{tr}-\bar{s})x_{tr(l)}\right| \le 2d\]</span> 令 <span class="math inline">\(\mu\)</span> 的隐私保护强度为 <span class="math inline">\(\epsilon_g\)</span> ，<span class="math inline">\(f_D(\omega)\)</span> 的隐私保护强度为 <span class="math inline">\(\epsilon_f\)</span></p><p>根据顺序组合定理，让 <span class="math inline">\(\epsilon_f+\epsilon_g = \epsilon\)</span> ，则 PFLR<span class="math inline">\(^*\)</span> 满足 <span class="math inline">\(\epsilon-differential {\,}{\,} privacy\)</span></p><hr /><center>PFLR*</center><hr /><ol type="1"><li>计算 <span class="math inline">\(\mu\)</span> 的全局敏感度 <span class="math inline">\(\Delta_g\)</span></li><li><span class="math inline">\(\mu = \{\mu_{(l)}\}_{l=1}^d\)</span> <span class="math inline">\(\mu_{(l)}=\sum_{i=1}^n(s_i-\bar{s})x_{(l)t_i}+Lap(0,\frac{\Delta_g}{\epsilon_g})\)</span> <strong><span style="background-color: cyan">将差分隐私加到  <span class="math inline">\(\mu\)</span> 的每个分量上</span></strong></li><li>用差分隐私扰动一阶多项式系数：<span class="math inline">\(\bar{\lambda}_1 =\left(\sum_{i=1}^n\lambda_{1t_i}+Lap(\mu,\frac{\Delta _f}{\epsilon_f}) \right)\)</span></li><li>用差分隐私扰动二阶多项式系数：<span class="math inline">\(\bar{\lambda}_2 =\left(\sum_{i=2}^n\lambda_{1t_i}+Lap(\mu,\frac{\Delta _f}{\epsilon_f}) \right)\)</span></li><li>扰动后的目标函数 <span class="math inline">\(\bar{f}_D(\omega)=\bar{\lambda}_1^T\Phi_1 + \bar{\lambda}_2^T\Phi_2\)</span> <strong><span style="background-color: cyan"><span class="math inline">\(\Phi_1\)</span> 和 <span class="math inline">\(\Phi_2\)</span> 分别为 1, 2 阶多项式</span></strong></li><li>计算权重 <span class="math inline">\(\bar{\omega} = arg\min_{\omega}\bar{f}_D(\omega)\)</span></li><li>返回 <span class="math inline">\(\bar{\omega}\)</span></li></ol><hr /><h3 id="section"></h3><h2 id="实验结果">5.实验结果</h2><p>实验过程：分别在 Adult 和 Dutch 数据集上做了 <span class="math inline">\(5\)</span> 组实验来验证算法的性能。</p><ul><li>普通的 <span class="math inline">\(Logistic\)</span> 回归</li><li>只使用差分隐私 PrivLR</li><li>只使用公平性</li><li>PFLR</li><li>PFLR*</li></ul><p><img src="http://image.lovemingming.cloud/image-20220407210223225.png" /></p><p>当隐私保护强度从 <span class="math inline">\(1 \rightarrow 0.1\)</span> 时，PrivLR ，PFLR 的精度快速下降，不公平程度快速上升。</p><p>而 PFLR*的精度和不公平程度在 <span class="math inline">\(\epsilon = 0.1\)</span> 时仍能保证较高的精度 <span class="math inline">\(74.91%\)</span>，较小的不公平程度 <span class="math inline">\(0.28%\)</span></p><blockquote><p>PFLR*的精度更高，说明它在保证 <span class="math inline">\(\epsilon\)</span> 隐私的情况下，注入的噪声比PrivLR 更少</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>差分隐私</tag>
      
      <tag>机器学习公平性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 中Boolean 和 boolean的区别</title>
    <link href="/2022/04/06/Java-%E4%B8%ADBoolean-%E5%92%8C-boolean%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/06/Java-%E4%B8%ADBoolean-%E5%92%8C-boolean%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="java-中-boolean-和-boolean-的区别">Java 中 Boolean 和 boolean 的区别</h1><h2 id="背景">背景</h2><p>布尔型是我们写逻辑时常用的类型。</p><p>Java 中提供的布尔型有 Boolean 和 boolean，它们在使用时很容易被误用。<strong>（毕竟只相差一个字符）</strong></p><p>有一次，我使用布尔型数组来存储数组中元素的使用情况。如果元素未被使用则对该元素执行操作。</p><p><strong>为了方便说明，代码进行了简化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java">Boolean[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">if</span> (used[<span class="hljs-number">1</span>]) &#123;<br>    System.out.println(<span class="hljs-string">&quot;被使用过了&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 执行具体操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果出现了空指针异常：<font color="red" size =3>Exception in thread "main" java.lang.NullPointerException</font></p><p><mark>当把上述代码中的第一行的 Boolean 改为 boolean 后，代码即可正常运行</mark></p><h2 id="boolean-和-boolean-的区别">boolean 和 Boolean 的区别</h2><p>boolean 是基础数据类型，而 Boolean 是它的封装类。</p><p>boolean 创建的对象的值默认是 false，而 Boolean 创建的对象在没有实例化之前是 null.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Boolean[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (Boolean flag : used) &#123;<br>    System.out.print(flag + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment">// 打印结果为null null null</span><br>        <br><span class="hljs-type">boolean</span>[] used1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (Boolean flag1 : used1) &#123;<br>    System.out.print(flag1 + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment">// 打印结果为 false false false</span><br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>在大多数情况下，使用 boolean 就已经足够。</p><p>需要用 HashMap() 这样的容器存储布尔类型时，只能使用 Boolean。<strong>( key，value 均是 object )</strong></p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>Java踩坑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Functional Mechanism: Regression Analysis under Differential Privacy</title>
    <link href="/2022/04/05/Functional-Mechanism-Regression-Analysis-under-Differential-Privacy/"/>
    <url>/2022/04/05/Functional-Mechanism-Regression-Analysis-under-Differential-Privacy/</url>
    
    <content type="html"><![CDATA[<h1 id="functional-mechanism-regression-analysis-under-differential-privacy">Functional Mechanism: Regression Analysis under Differential Privacy</h1><h2 id="摘要">1. 摘要</h2><p>差分隐私是一种能在保护隐私的同时发布敏感数据的方法。</p><p>目前，已经提出了很多种方法将差分隐私应用到回归分析中。但是，这些方法要么只能在某些非标准类型的回归中使用，</p><p>要么就无法达到足够的精度。于是，为了解决上面的两个问题，作者提出了函数机制，并将它应用到了线性回归和 logistic 回归上。</p><p>那么函数机制有什么特别之处呢？现有的方法都是直接扰动最终的结果，而函数机制是在目标函数上进行扰动。</p><h2 id="介绍">2. 介绍</h2><h3 id="函数机制的设计难点">2.1 函数机制的设计难点</h3><ol type="1"><li>扰动目标函数比扰动标量要论难的多</li><li>直接在目标函数的系数上加人噪声很容易导致注入了过量的噪声，从而导致函数无法收敛</li><li>部分目标函数被扰动后可能失效，比如产生了无界的结果，或者多个局部最优。</li></ol><h3 id="函数机制的优点">2.2 函数机制的优点</h3><ul><li>对于线性回归和 logistic 回归，无论训练集的规模是多少，加入的噪声量是恒定的。</li><li>在 <span class="math inline">\(\epsilon\)</span> - differential privacy上就能实现，不需要使用松弛化项 <span class="math inline">\(\delta\)</span></li></ul><h2 id="准备工作">3. 准备工作</h2><h3 id="线性回归">3.1 线性回归</h3><p>线性回归假设目标值和特征之间线性相关，即可以通过多个特征来预测目标值。线性回归可以由以下公式表示： <span class="math display">\[\widehat{y} = \omega x + b （线性回归的一般表示）\]</span> 其中，<span class="math inline">\(\omega\)</span> 是权重，b是偏移量。</p><blockquote><p>线性回归的一个经典例子就是房价预测，使用占地面积，地段，房龄等特征来预测房价</p></blockquote><p>线性回归使用均方误差来做损失函数，用梯度下降法来不断修正参数，使得预测结果变得越来越精确。</p><p>线性回归损失函数为 <span class="math inline">\(L(\omega,b) =\frac{1}{n}\sum_{i=1}^n(\omega x_i + b - y_i)^2\)</span></p><p>线性回归的核心思路就是通过梯度下降求解损失函数最小时的 $^* $ 和 <span class="math inline">\(b^*\)</span> <span class="math display">\[(\omega ^*,b^*) = argmin(\omega,b)\sum_{i=1}^n(\omega x_i + b - y_i)^2\]</span></p><h3 id="logistic-回归">3.2 Logistic 回归</h3><p>Logistic 回归常用于分类问题。它使用sigmoid函数将原函数转化成一个值在 <span class="math inline">\((0,1)\)</span> 之间的分布。例如，我们可以将预测值大于 <span class="math inline">\(0.5\)</span> 的个体分为一类，小于等于 <span class="math inline">\(0.5\)</span> 的个体分为第二类。Logistic 的一般公式为：<span class="math inline">\(\widehat{y}=\frac{e^{\omega x}}{1+e^{\omega x}}\)</span></p><center>​ <img src ="/img/sigmoid.png" width = 400px height =300px  ></center><p>和线性回归不同的是，Logistic 回归的损失函数为对数损失函数。公式表示如下： <span class="math display">\[L(\omega,b) = -[y{\,}log{\,}\widehat{y}+(1-y)log(1-\widehat{y})]\]</span> 该损失函数可用分段函数表示为 <span class="math display">\[L(\omega,b) =\left\{\begin{matrix} -log({\,}\widehat{y}){\,} \quad \quad \quad y=1 \\ -log({\,}1-\widehat{y}){\,}{\,} \quad  y=0\end{matrix}\right.\]</span></p><blockquote><p>Logistic 回归通过最小化损失函数来实现更精准的分类。</p></blockquote><h3 id="epsilon--differential-privacy">3.3 <span class="math inline">\(\epsilon\)</span>- Differential Privacy</h3><blockquote><p>差分隐私使查询随机化，让攻击者无法判断某条记录是否在数据集中。</p></blockquote><p>如果一个随机化算法 <span class="math inline">\(\mathcal{A}\)</span> 满足 $$- Differential Privacy，那么 <span class="math inline">\(A\)</span> 在任意两个相邻数据集 <span class="math inline">\(D1\)</span> 和 <span class="math inline">\(D2\)</span> 上的输出满足： <span class="math display">\[Pr[\mathcal{A}(D_1) = O ]{\,}\le e^\epsilon\cdot Pr[\mathcal{A}(D_2) = O]\]</span> 其中 <span class="math inline">\(O\)</span> 表示输出的结果 ，<span class="math inline">\(Pr\)</span> 表示概率。</p><p><span class="math inline">\(\epsilon\)</span>为隐私保护强度，<span class="math inline">\(\epsilon\)</span>越大，数据可用性越高，隐私保护强度越低。反之亦然。</p><h3 id="拉普拉斯机制">3.4 拉普拉斯机制</h3><blockquote><p>实现差分隐私最简单的方式就是将拉普拉斯噪声注入到查询的结果中。</p></blockquote><p>设查询为 <span class="math inline">\(f(x)\)</span> ，扰动后的查询为 <span class="math inline">\(F(x)\)</span> ，那么 <span class="math inline">\(F(x) = f(x){\,}+Lap(\frac{s}{\epsilon})\)</span></p><p>其中，<span class="math inline">\(Lap(\frac{s}{\epsilon})\)</span> 是满足拉普拉斯分布的噪声。</p><p><span class="math inline">\(s\)</span> 为全局敏感度，设 <span class="math inline">\(D1\)</span> 和 <span class="math inline">\(D2\)</span> 是两个相差只有一条记录的兄弟数据集，<span class="math inline">\(Q\)</span> 为查询函数。<span class="math inline">\(s\)</span> 等于任意两个兄弟数据集查询结果的<span class="math inline">\(L_1\)</span>范数的最大值： <span class="math display">\[s = max{\,}||Q(D_1)-Q(D2)||_1\]</span></p><h3 id="符号定义">3.5 符号定义</h3><table><thead><tr class="header"><th style="text-align: center;">符号</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(D\)</span></td><td style="text-align: center;">包含 n 条记录的数据集</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(t_i = (x_i,y_i)\)</span></td><td style="text-align: center;">数据集 D 中的第 i 条记录</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(d\)</span></td><td style="text-align: center;">特征向量 <span class="math inline">\(x_i\)</span> 的特征数</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\omega\)</span></td><td style="text-align: center;">回归模型的权重向量</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(f(t_i,\omega)\)</span></td><td style="text-align: center;">回归模型的损失函数</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(f_D(\omega)\)</span></td><td style="text-align: center;"><span class="math inline">\(f_D(\omega) = \sum_{t_i\in D}f(t_i,\omega)\)</span> | 对所有记录的损失函数求和</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\omega^*\)</span></td><td style="text-align: center;"><span class="math inline">\(\omega^* = argmin_{\omega} f_D(\omega)\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\bar{f}_D(\omega)\)</span></td><td style="text-align: center;">扰动后的<span class="math inline">\(f_D(\omega)\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\bar{\omega}\)</span></td><td style="text-align: center;"><span class="math inline">\(\bar{f}_D(\omega)\)</span> 最小时对应的权重<span class="math inline">\(\omega\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\widetilde{f}_D(\omega)\)</span></td><td style="text-align: center;">对 <span class="math inline">\(f_D(\omega)\)</span> 泰勒展开后得到的损失函数</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\widetilde{\omega}\)</span></td><td style="text-align: center;"><span class="math inline">\(\widetilde{f}_D(\omega)\)</span> 最小时对应的权重<span class="math inline">\(\omega\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\widehat{f}_D(\omega)\)</span></td><td style="text-align: center;">取泰勒展开式中的低次项构成的渐进函数</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\widehat{\omega}\)</span></td><td style="text-align: center;"><span class="math inline">\(\widehat{f}_D(\omega)\)</span> 最小时对应的权重<span class="math inline">\(\omega\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\phi\)</span></td><td style="text-align: center;"><span class="math inline">\(\omega\)</span> 中的各个分量运算得到的结果（与二项展开式有关）如<span class="math inline">\((\omega_1)^3\cdot\omega^2\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\Phi_j\)</span></td><td style="text-align: center;">所有幂为 <span class="math inline">\(j\)</span> 的 <span class="math inline">\(\phi\)</span> 对应的集合</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\lambda_{\phi_{t_i}}\)</span></td><td style="text-align: center;">第 <span class="math inline">\(i\)</span> 条记录对应的 <span class="math inline">\(\phi\)</span> 的多项式系数（这里有多个，因为 <span class="math inline">\(\phi\)</span>的幂有多个）</td></tr></tbody></table><h3 id="部分说明">3.6 部分说明</h3><ul><li><p>设 <span class="math inline">\(D\)</span> 包含 <span class="math inline">\(n\)</span> 条记录 <span class="math inline">\(t_1,t_2,...t_n\)</span> ，每条记录包含 <span class="math inline">\(n+1\)</span> 个属性，<span class="math inline">\(X_1,X_2...X_d,Y\)</span>。</p><p>假设不失一般性， <span class="math inline">\(\sqrt{\sum^d_{j=1}x^2_{ij}}\le1\)</span> （第 <span class="math inline">\(i\)</span> 条记录的特征的 L2 范数小于等于 1 ）</p><p><mark>这里我觉得是因为对数据做了规范化处理（均值为0，方差为1）</mark></p></li><li><p>为了方便进行讨论，论文所有的属性都是二值属性，即 0 或 1 。如果有多值，比如婚姻状况，有未婚，已婚，丧偶三种。则将这个三值属性转换成两个二值属性，即是否已婚，是否丧偶。</p></li></ul><h2 id="函数机制">4.1 函数机制</h2><p>直接在目标函数上进行扰动，极具挑战。这主要是因为权重 <span class="math inline">\(\omega\)</span> 的全局敏感度分析起来十分困难。</p><p>根据 <span class="math inline">\(Stone\)</span> - <span class="math inline">\(Weierstrass\)</span> 定理，任何连续可微分的函数 <span class="math inline">\(f(x)\)</span> 可以由一个多项式 <span class="math inline">\(Ax^n +Bx^n-1...+Kx^1+bx^0\)</span>来表示。</p><p><mark>这样，在将原函数转换成多项式形式后。就可以在多项式系数上加入噪声，而不是在权重 <span class="math inline">\(\omega\)</span> 上加入噪声。</mark></p><p>在回归问题中，对于训练集中的一条记录，目标函数为 <span class="math inline">\(f(t_i,\omega)\)</span> 。这里的 <span class="math inline">\(\omega\)</span> 就可以看作是 <span class="math inline">\(f(x)\)</span> 中的 <span class="math inline">\(x\)</span> 。</p><p>向量 <span class="math inline">\(\omega\)</span> 中包含 <span class="math inline">\(d\)</span> 个值 <span class="math inline">\(\omega_1,\omega_2...\omega_d\)</span>，令 <span class="math inline">\(\phi\)</span> 为 <span class="math inline">\(\omega\)</span> 中的各个分量幂运算得到的结果<strong>（这里与二项式定理有关）</strong>。</p><p><span class="math inline">\(\Phi_j\)</span> 为所有幂为 <span class="math inline">\(j\)</span> 的 <span class="math inline">\(\phi\)</span> 对应的集合，公式表达如下： <span class="math display">\[\Phi_j =\left\{\begin{matrix}\omega_1^{c_1}\omega_2^{c_2}...\omega_d^{c_d}|\sum_{l=1}^dc_l=j \end{matrix}\right\}\]</span> 例如，<span class="math inline">\(\Phi_0=\left\{\begin{matrix}1 \end{matrix}\right\}\)</span> ，<span class="math inline">\(\Phi_1=\left\{\begin{matrix}\omega_1,\omega_2...,\omega_d \end{matrix}\right\}\)</span> ，<span class="math inline">\(\Phi_2=\left\{\begin{matrix}\omega_i\cdot\omega_j|i,j \in[1,d]\end{matrix}\right\}\)</span> 。</p><p>这里其实就是对 <span class="math inline">\(\omega\)</span> 求幂，<span class="math inline">\(\omega^0 = 1\)</span> ，<span class="math inline">\(\omega^1=\left\{\begin{matrix}\omega_1,\omega_2...,\omega_d \end{matrix}\right\}\)</span>，<span class="math inline">\(\omega^2=\left\{\begin{matrix}\omega_i\cdot\omega_j|i,j \in[1,d]\end{matrix}\right\}\)</span></p><p>设 <span class="math inline">\(J\)</span> 为多项式的最高次幂，<span class="math inline">\(J\in[0,\infty]\)</span> ，<span class="math inline">\(\lambda_{\phi_{t_i}}为多项式系数\)</span>， <span class="math inline">\(f(t_i,\omega)\)</span> 为可以由多项式表示为： <span class="math display">\[f(t_i,w)=\sum^J_{j=0}\sum_{\phi\in\Phi_j}\lambda_{\phi_{t_i}}\phi(\omega)\]</span> 因为函数机制是在多项式系数上加入拉普拉斯噪声，所以我们需要求解多项式系数的全局敏感度 <span class="math inline">\(s\)</span></p><p>对于兄弟数据集 <span class="math inline">\(D\)</span> 和 <span class="math inline">\(D&#39;\)</span>，它们的目标函数可以由如下多项式表示： <span class="math display">\[f(t_i,\omega) =\sum^J_{j=0}\sum_{\phi\in\Phi_j}\sum_{t_i \in D}\lambda_{\phi_{t_i}}\phi(\omega)，\\f(t_i,\omega) =\sum^J_{j=0}\sum_{\phi\in\Phi_j}\sum_{t_i \in D_1}\lambda_{\phi_{t_i}}\phi(\omega).\]</span> 对它们的多项式作差，可得如下不等式： <span class="math display">\[\sum^J_{j=0}\sum_{\phi\in\Phi_j}\Arrowvert\sum_{t_i\in D}\lambda_{\phi_{t_i}}-\sum_{t_i’\in D’}\lambda_{\phi_{t_i ’}}\Arrowvert_1 \le 2{\,}max(t)\sum_{j=1}^J\sum_{\phi\in\Phi_j}\Arrowvert\lambda_{\phi_t}\Arrowvert_1\]</span></p>根据上述，可以得到函数机制的算法流程：<center><img src ="/img/function mechanism.jpg"  ></center><h3 id="泰勒展开式">4.2 泰勒展开式</h3><p>泰勒展开是用一个多项式函数 <span class="math inline">\(g(x)\)</span> 来仿造原函数 <span class="math inline">\(f(x)\)</span> 的方法，使这两个函数在某一点的初始值相等，<span class="math inline">\(1\)</span> 阶导数相等，<span class="math inline">\(2\)</span> 阶导数相等，</p><p>.... <span class="math inline">\(n\)</span> 阶导数相等。泰勒展开式在点 <span class="math inline">\(x_0\)</span> 处的表达式如下： <span class="math display">\[g(x) = g(x_0)+\frac{f^1(x_0)}{1!}x + \frac{f^2(x_0)}{2!}x^2+......\frac{f^n(x_0)}{n!}x^n\]</span> 知乎上有个很好的帖子来理解泰勒展开式：<a href="https://www.zhihu.com/question/25627482">怎样更好的理解并记忆泰勒展开式?</a></p><h3 id="将函数机制应用到线性回归上">4.3 将函数机制应用到线性回归上</h3><p>前面说到，函数机制用多项式来渐进目标函数，而线性回归的损失函数本身就是多项式，所以可以直接在损失函数的多项式系数上加噪声。</p><p>线性回归的目标函数: <span class="math display">\[f_D(\omega) = \sum_{t_i\in D}(y_i-x_i^T\omega)^2 =\\\sum_{t_i\in D}(y_i)^2-\sum_{j=1}^d\left(2\sum_{t_i\in D}y_ix_{ij}\right)\omega_j +\sum_{1\le j,l \le d}\left(\sum_{t_i \in D}x_{ij}x_{il}\right)\omega_j\omega_l\]</span> 全局敏感度求解如下： <span class="math display">\[\Delta = 2{\,} \max_{t=(x,y)}\sum_{j=1}^J\sum_{\phi\in\Phi_J}||\lambda_{\phi_t}||_1  {\,} \le 2{\,} \max_{t=(x,y)}\left(y^2+2\sum_{j=1}^dyx_{(j)}+\sum_{1\le j,l \le d}x_{(j)}x_{(l)}\right) \le 2{\,}(1+2d+d^2)\]</span> <span class="math inline">\(\because y \in [-1,1] \rightarrow max({\,}y^2) = 1,max(yx_j)=1\)</span></p><p>将求解得到的全局敏感度 <span class="math inline">\(\Delta\)</span> 带入到算法1中即可求解。</p><h3 id="将函数机制应用到-logistic-回归上">4.4 将函数机制应用到 Logistic 回归上</h3><p><span class="math inline">\(Logistic\)</span> 回归的损失函数本身不是多项式，需要使用泰勒展开式构造一个多项式。</p><p>Logistic 回归的损失函数为：<span class="math inline">\(f_D(w) = -[y{\,}log{\,}x_i^T\omega+(1-y)log(1-x_i^T\omega)]\)</span></p><p><strong>论文证明在 Logistic 回归中泰勒展开到二阶就能保证构造的多项式函数相对于原函数损失只有 <span class="math inline">\(\approx 0.015\)</span></strong></p><p>我们将 Logistic 回归的损失函数用泰勒在 <span class="math inline">\(0\)</span> 处展开到二阶<u>（后面一项本身是多项式不需要展开）</u> <span class="math display">\[\widehat{f}_D(\omega)=\sum_{i=1}^n\sum_{k=0}^2\frac{f_1^{(k)}(0)}{k!}\left(x_i^T\omega\right)^k -\left(\sum_{i=1}^ny_ix_i^T\right)\omega\]</span> 对应的全局敏感度 <span class="math inline">\(\Delta\)</span> 为 <span class="math display">\[\Delta = 2{\,}\max_{t={(x,y)}}\left(\frac{f_1^{(1)}(0)}{1!}\sum_{j=1}^dx_{(j)}+\frac{f_1^{(2)}(0)}{2!}\sum_{j,l}x_{(j)}x_{(l)}+y\sum^d_{j=1}x_{(j)}\right) \\\le 2 {\,}(\frac{d}{2}+\frac{d^2}{8}+d) = \frac{d^2}{4}+3d\]</span> 将 <span class="math inline">\(\Delta\)</span> 带入到算法1中即可求解</p><h2 id="避免注入的噪声使损失函数无法收敛">5. 避免注入的噪声使损失函数无法收敛</h2><blockquote><p>使用函数机制 <span class="math inline">\(Logistic\)</span> 回归中注入噪声，可能会导致损失函数无法收敛。</p></blockquote><p>我们在对 <span class="math inline">\(Logistic\)</span> 进行低阶泰勒展开后，得到的是一个二阶多项式。</p><p>为了方便描述，我们令这个式子为<span class="math inline">\(Ax^2+bx+c\)</span>. 当 <span class="math inline">\(A&gt;0\)</span> 时，损失函数为一个开口向上的抛物线。</p><p>如果加入对多项式系数扰动后，<span class="math inline">\(A&lt;0\)</span> 那么损失函数就变成了一个开口向下的抛物线，那么就导致损失函数无法收敛到最小值处。</p><p>所以在 <span class="math inline">\(Logistc\)</span> 回归中需要保证多项式的二次项系数加噪后仍然为正。</p><p>论文中给出的一个解决方式是：如果发现 <span class="math inline">\(A&lt;0\)</span> 了，重新运行函数机制，直到它扰动后为正。</p><h2 id="实验">6. 实验</h2><p>作者将自己的算法与<span class="math inline">\(DPME\)</span>，<span class="math inline">\(Filter-Priority\)</span>，Truncated 以及不加差分隐私的算法进行了对比，结果证明函数机制造成的性能损失更小，训练时间更短，基本上是完胜其他几个算法<del>（在我的论文里，你们是无法战胜我的）</del>。</p><blockquote><p>原作者使用的matlab进行实验且代码未公开，具体性能需要复现后才能知道。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>差分隐私</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java List 与地址相关的一点坑</title>
    <link href="/2022/04/03/Java-List-%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E7%82%B9%E5%9D%91/"/>
    <url>/2022/04/03/Java-List-%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E7%82%B9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="java-踩坑系列-一list">Java 踩坑系列 （一）List</h1><span id="more"></span><h2 id="踩坑过程">踩坑过程</h2><p>今天刷回溯法 <a href="https://leetcode-cn.com/problems/combinations/">leetcode-77-组合</a> 的时候。</p><p>因为返回值是 <strong> List&lt;List&lt;Integer&gt;&gt;</strong>，所以可以使用一个 <strong>List&lt;Integer&gt;</strong> 的对象来进行回溯。于是我想当然的写出了以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, List&lt;Integer&gt; temp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (temp.size() == k) &#123; <span class="hljs-comment">//当temp的size已经是k时，加入到ans中，退出</span><br>            ans.add(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n; i++) &#123; <span class="hljs-comment">//因为不考虑重复的&#123;「1，2」和「2，1」算重复，这里还没有剪枝</span><br>            temp.add(i);<br>            backTracking(i + <span class="hljs-number">1</span>, n, k, temp); <span class="hljs-comment">//回溯</span><br>            temp.remove(temp.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">//回溯完，往上</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">//</span><br>        backTracking(<span class="hljs-number">1</span>, n, k, temp);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Solution</span> <span class="hljs-variable">solution</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>        List&lt;List&lt;Integer&gt;&gt; combine = solution.combine(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>        System.out.println(combine);<br>    &#125;<br></code></pre></td></tr></table></figure><p>结果运行的时候，出来的结果是这样的</p><blockquote><p>[[], [], [], [], [], []]</p></blockquote><h2 id="原因">原因</h2><p><strong>分析结果：</strong>返回值是规模是正确的，但是里面的值全都神秘消失了。</p><p>我调试了一遍程序，发现每一轮 <em>temp</em> 都被顺利加入到了 <em>ans</em> 中。但是当我对 <em>temp</em> 进行回溯时，会移除前一步中加入的元素，此时 <em>ans</em> 里加入的 <em>temp</em> 也发生了变化！<mark color='g'>实际上，在这段代码里 <em>ans</em> 中的每个子元素都指向 <em>temp</em>。因此当 <em>temp</em> 变化时，<em>ans</em> 里的每个元素也发生了变化。</mark>最后的回溯将 <em>temp</em> 清空了，所以也就出现了上面的情况。于是对代码稍做修改，答案就正确了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, List&lt;Integer&gt; temp)</span> &#123;<br>    <span class="hljs-keyword">if</span> (temp.size() == k) &#123; <span class="hljs-comment">//当temp的size已经是k时，加入到ans中，退出</span><br>        List&lt;Integer&gt; cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(temp);<br>        ans.add(cur);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n; i++) &#123; <span class="hljs-comment">//因为不考虑重复的&#123;「1，2」和「2，1」算重复，这里还没有剪枝</span><br>        temp.add(i);<br>        backTracking(i + <span class="hljs-number">1</span>, n, k, temp); <span class="hljs-comment">//回溯</span><br>        temp.remove(temp.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">//回溯完，往上</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;<br>    List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <br>    backTracking(<span class="hljs-number">1</span>, n, k, temp);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]</p></blockquote><p>最后对第 8 行稍做修改，实现剪枝操作，就能较快的 AC 了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= n - (k - temp.size()) + <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//因为不考虑重复的&#123;「1，2」和「2，1」算重复</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>Java踩坑系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
